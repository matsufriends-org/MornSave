using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerators;

[Generator]
public class SavePropertyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // GenerateSaveProperties属性を持つクラスを検出
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)!;

        // コンパイルと検出したクラスを結合
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // ソースコードを生成
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax c && c.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // GenerateSaveProperties属性を持つかチェック
        foreach (var attributeList in classDeclarationSyntax.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attribute).Symbol is not IMethodSymbol attributeSymbol)
                    continue;

                var attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                var fullName = attributeContainingTypeSymbol.ToDisplayString();

                if (fullName == "PastelParade.GenerateSavePropertiesAttribute")
                    return classDeclarationSyntax;
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        foreach (var classDeclaration in classes)
        {
            var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(classDeclaration);
            if (classSymbol == null)
                continue;

            var source = GeneratePropertyCode(classSymbol, classDeclaration, model);
            context.AddSource($"{classSymbol.Name}_Generated.cs", source);
        }
    }

    private static string GeneratePropertyCode(INamedTypeSymbol classSymbol, ClassDeclarationSyntax classDeclaration, SemanticModel semanticModel)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using UniRx;");
        sb.AppendLine("");
        
        if (!string.IsNullOrEmpty(classSymbol.ContainingNamespace?.ToDisplayString()))
        {
            sb.AppendLine($"namespace {classSymbol.ContainingNamespace.ToDisplayString()}");
            sb.AppendLine("{");
        }
        
        sb.AppendLine($"    public partial class {classSymbol.Name}");
        sb.AppendLine("    {");

        // SaveProperty属性が付いたフィールドを探す
        var fields = GetFieldsWithSavePropertyAttribute(classSymbol);
        
        foreach (var (field, attribute) in fields)
        {
            GenerateProperty(sb, field, attribute);
        }

        sb.AppendLine("    }");
        
        if (!string.IsNullOrEmpty(classSymbol.ContainingNamespace?.ToDisplayString()))
        {
            sb.AppendLine("}");
        }
        
        return sb.ToString();
    }

    private static IEnumerable<(IFieldSymbol field, AttributeData attribute)> GetFieldsWithSavePropertyAttribute(INamedTypeSymbol classSymbol)
    {
        return classSymbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Select(field => 
            {
                var attr = field.GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass?.Name == "SavePropertyAttribute" || 
                                       a.AttributeClass?.ToDisplayString() == "PastelParade.SavePropertyAttribute");
                return (field, attr);
            })
            .Where(tuple => tuple.attr != null);
    }

    private static void GenerateProperty(StringBuilder sb, IFieldSymbol field, AttributeData attribute)
    {
        var fieldName = field.Name;
        var subjectName = fieldName + "Subject";
        var propertyName = GetPropertyName(fieldName);
        var fieldType = field.Type.ToDisplayString();
        
        // 属性からアクセスレベルを取得
        var accessLevel = GetAccessLevel(attribute);

        // アクセスレベルがFullの場合のみ、SubjectとObservableを生成
        if (accessLevel == "Full")
        {
            sb.AppendLine($"        private Subject<{fieldType}> {subjectName};");
            sb.AppendLine($"        public IObservable<{fieldType}> On{propertyName}Changed => {subjectName} ??= new Subject<{fieldType}>();");
            sb.AppendLine();
        }

        // プロパティの定義
        sb.AppendLine($"        public {fieldType} {propertyName}");
        sb.AppendLine("        {");
        sb.AppendLine($"            get => {fieldName};");
        
        // GetterOnlyの場合はsetterを生成しない
        if (accessLevel != "GetterOnly")
        {
            sb.AppendLine("            set");
            sb.AppendLine("            {");
            sb.AppendLine($"                if (!EqualityComparer<{fieldType}>.Default.Equals({fieldName}, value))");
            sb.AppendLine("                {");
            sb.AppendLine($"                    {fieldName} = value;");
            
            // Fullの場合のみ通知を発行
            if (accessLevel == "Full")
            {
                sb.AppendLine($"                    {subjectName}?.OnNext(value);");
            }
            
            sb.AppendLine("                }");
            sb.AppendLine("            }");
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
    }
    
    private static string GetAccessLevel(AttributeData attribute)
    {
        // コンストラクタ引数を取得
        if (attribute.ConstructorArguments.Length > 0)
        {
            var arg = attribute.ConstructorArguments[0];
            if (arg.Value is int enumValue)
            {
                return enumValue switch
                {
                    0 => "GetterOnly",
                    1 => "GetterSetter",
                    2 => "Full",
                    _ => "Full"
                };
            }
        }
        return "Full"; // デフォルト
    }

    private static string GetPropertyName(string fieldName)
    {
        // _levelName -> LevelName
        if (fieldName.StartsWith("_"))
            fieldName = fieldName.Substring(1);
        
        // 最初の文字を大文字に
        if (fieldName.Length > 0)
            return char.ToUpper(fieldName[0]) + fieldName.Substring(1);
        
        return fieldName;
    }
}